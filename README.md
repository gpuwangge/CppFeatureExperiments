# Build Instruction
Go to the project dir  
> mkdir build  
> cd build  
> cmake -G "MinGW Makefiles" ..  
> make  

# Cpp11Example
## 右值引用(rvalue reference)
解释右值引用之前，首先要解释什么是左值、右值和引用  
左值(Lvalue)：有名字的对象。因为有名字，就可以在内存中找到位置，可以被访问。比如，变量x就是一个左值。  
右值(Rvalue)：没有名字的对象。即是一个临时对象。比如，数字42或表达式x+y都是右值。  
引用(Reference)：给一个已经有名字的对象(左值)创建一个别名(另一个左值)。比如&a = b  
如上可以很容易推导出右值引用的定义  
右值引用(Rvalue Reference): 给一个没有名字的对象(右值)赋予一个新的或已经存在的别名(左值)。比如&&a = 42，a是一个左值，&&a是一个右值引用。  

右值引用有什么用处  
值得一提的是，&&a = 42这种把右值直接绑定到右值引用的行为没有意义，仅仅是用于学习和理解什么是右值引用。  
在实际运用的时候，往往是将一个左值转换成右值后，在绑定到右值引用。  
因为如果把一个左值直接赋值给另一个左值，会出现拷贝。  
通过右值引用，可达到把一个左值赋值给另一个左值，又不引起拷贝。  

关于拷贝的一些实验  
观察程序在什么时候会出现拷贝。  
对于简单的数据类型，比如int，float，进行赋值的时候并不会出现拷贝，比如  
```c++
int a = 42;
```
这段代码把一个临时对象(右值)赋予左值，并没有出现拷贝。  
但是当=号右边也是左值的时候，会出现拷贝：  
```c++
int a = 42;
int b = a;
```
a和b都是左值(都有名字)，当处理到int b = a这条语句的时候，涉及到把名字为a内存里面的数据拷贝到名字为b的内存里。  
（这时候打印a和b的地址，观察结果）  
如果不想发生拷贝，应该使用如下方式  
```c++
int a = 42;
int &&b = std::move(a);
```
std::move把a强行转化成右值，然后绑定到b上  
（这时候打印a和b的地址，观察结果）  
另一个有趣的实验是不适用标准库函数std::move，而是使用强制转换，可以达到同样的效果  
```c++
int a = 42;
int &&b = (int &&)a;
```
（这时候打印a和b的地址，观察结果）  
但是值得一提的是，虽然本例中std::move和(int &&)最后的结果相同，但是后者是更加低级的方法；如果是一个比较复杂的对象，后者容易出错，不太安全，还是推荐用std::move来进行安全的转换。  

以上例子说明了右值引用的好处。但int本身是简单的类型，拷贝本身开销也不大。  
然而，对于比较复杂的类的对象或容器，其拷贝的成本非常巨大，右值引用的好处就显现了。  

## 在类中使用std::move
上面提到，std::move的作用是强制把左值转换成右值，从而实现赋值的时候避免拷贝资源(也就是"转移"资源)  

一个常见的应用场景是类中使用std::move实现高效率的类的资源转移(从而避免深拷贝)  
例如，原本类只有"拷贝构造函数"和"拷贝赋值运算符"进行深拷贝，对于两者来说，深拷贝的操作都无法避免  
现在，在类中添加"移动构造函数"(很像拷贝构造函数，但函数输入使用了&&而不是&，并且函数内赋值的时候需要std::move)和"移动赋值运算符"(类似，函数输入也是&&,函数内部也是用std::move来转换)  

在使用的时候，如果使用MyClass obj1=obj2; 就会调用拷贝构造函数；如果使用obj1=std::move(obj2)就会使用移动构造函数，避免了拷贝过程  

同样，如果使用MyClass obj1; obj1=obj2; 就会调用拷贝赋值运算符；如果使用MyClass obj1; obj1=std::move(obj2)就会使用移动赋值运算符，避免了拷贝过程  

综上所述，在C++中，std::move是一个标准库函数，用于实现对象的移动语义。移动语义允许资源从一个对象转移到另一个对象，而不是进行昂贵的复制操作。这在处理动态内存分配、文件句柄等资源时特别有用，可以显著提高程序的性能。  
在C++11之前，复制对象通常会涉及深拷贝操作，这可能会非常昂贵，尤其是对于包含大量数据的对象。C++11引入了移动语义，通过移动构造函数和移动赋值运算符来优化这种情况。  

  
# CppBasicExample
## 内存分区模型
C和C++都一样  
Windows, Linux和macOS都一样  
- Code Segment：存编译后的二进制可执行代码，共享，只读  
- Data Segment(全局区)  
    Static Segment: 存全局变量(跨文件)和静态变量(局部)  
    Constant Segment：存常量数据(和静态变量的区别是必须定义时初始化，而且不可改变), 但是局部常量不在这里，在下面那个区  
- Stack Segment: 存局部变量，函数参数和函数调用的返回地址。由编译器分配。(不要返回局部变量的地址)  
- Heap Segment: 存动态内存  

结论1: 前两区是程序运行前建立的区，后面两区是程序运行后建立的区  
结论2: const修饰不决定数据放在哪里。如果是局部的就在stack区；全局的都在data区。  
结论3: static的都在data区。因为在整个程序生命周期都存在。  

## Friend
Friend让一个类或函数访问另一个类的私有成员  
1.全局函数做友元  
做一个全局函数，让它可以访问类的公有和私有属性。  
做法是，把全局函数的定义放在类的最前面，并加上friend关键字。  
2.类做友元  
做法是，把另一个类的名字拷贝到自己类的最前面，并加上friend关键字。  
3.成员函数做友元  
跟2相比，就是不把visit权限给整个类，而只是给类里面的某些成员函数。  

## 常函数
常函数：成员对象后面加上const  
常函数内不可修改成员变量（除非成员变量加了mutable)  

## 常对象
常对象：生命对象前加上const  
常对象只能调用常函数  

## this指針
在类的存放的时候，非静态成员变量和非静态成员函数是分开存放的。非静态成员变量每个对象存一份。但每个非静态成员函数只存一份，所有对象共享。  
问题是，对于非静态成员函数的代码，它不知道是哪个对象在调用它。this指针是为了解决这个问题，它指向调用这个非静态成员函数的类的对象。  
this指针不可修改  
每个非静态成员函数都有this指针，不需要单独设定。  
应用举例：链式编程  
```c++
Person& func(){  
    return *this;  
}
```

## 类和对象
空的对象大小是多少：占用1个字节。cpp编译器给空对象分配1字节空间，是为了区分位置。  
- 放一个int成员变量后，大小为4个字节。  
- 静态成员变量不影响类的对象的大小。  
- 放一个成员函数后，不影响类的对象的大小。(成员函数和成员变量分开存储)  
- 静态成员函数：也不影响类的对象的大小。  
结论：只有非静态成员变量位于类的对象上。  

## 重载
运算符重载可以在类里重载，也可以在全局重载。类里面重载没法指定顺序(比如<<)  

c++编译器给一个类创建的时候创建了四个默认函数  
构造  
析构  
拷贝构造(浅拷贝)  
赋值(浅拷贝)  

## 继承
子类继承父类之后，也会有一份父类的数据。  
比如父类有三个int(public, protected, provate), 子类有一个int，总大小就为16 bytes。  

cl和g++都有相应的命令可以查看类的对象详情  

如果父类和子类有同名成员，默认调用子类成员。如果加上作用域也可以调用父类成员。比如：s.Base::m_A  

允许一个子类继承多个类  

菱形继承：两个父类继承了一个类  
问题：子类继承了两份相同的数据  
解决办法：virtual inheritance  

## 纯虚函数和抽象类
因为父类virtual函数一般是没什么用的，可以改成纯虚函数(virtual = 0)  
类中只要有一个纯虚函数，就叫做抽象类，无法实例化。抽象类的子类必须重写抽象类的纯虚函数。  

## 多肽
overload其实是静态多肽  
polymorthism是运行阶段确定，是动态多肽  
要让地址晚绑定，使用virtual关键字  
动态多肽发动条件  
1.有继承关系   
2.重写父类virtual函数  
重写和重载的区别是，前者完全相同  
子类可以加上virtual，也可以不加virtual，没有影响  
3.使用的时候，使用父类的指针或引用来使用子类的对象  

多肽的底层原理  
如果一个类里面有一个函数，没有virtual修饰，算是一个空类，大小是1字节。如果用virtual修饰，大小变成4个字节。这4个字节是一个指针，指向virtual function table。  
VFT会存method address。当继承的时候，子类会继承父类的VFT。如果没有重写，那这个指针跟父类一样；如果发生了重写，指针会换成重写后的method adress。当用父类指针指向子类对象的时候，会直接访问VFT里的地址，也就是说假如发生了重写，必然调用的是子类的method。  

## 模版
template<typename T>  
template<class T>  
以上两个用法等同  

模版也分为函数模版和类模版两类。  
区别仅仅是类模版无法自动类型推导，也就是用<>显式指出类型。  

对于某个具体情况，可以使用具体化模版来解决特殊类型的通用化  

STL是基于模版来写的  

类模版的成员函数在调用的时候才确定  

类模版做参数对象  

类模版与继承：  
如果父类是模版，子类必须指定父类T的类型才行，不然会报错。  
要想更灵活一点，子类也要写成模版。并且子类的模版参数T继承自父类的模版参数T  

类模版成员函数可以类外实现：  
除了添加函数模版keyword，还要指定类模版参数列表  

类模版分文件编写：  
类模版成员函数创建时机是在调用阶段，会导致分文件编写时链接不到  
解决方式1:直接包含cpp源文件  
但实践中很少有人这么做  
解决方式2:将声明和实现写在同一个文件中，然后文件后缀改成hpp(改hpp并不是强制，只是约定成俗)  
大家约定俗成：当看见hpp文件之后，里面就有类模版  

类模版与友元：  
第一种方式：类内直接写  
第二种方式：类外需要提前让编译器知道全局函数的实现  
这种实现方式比较复杂。  


