# Build Instruction
Go to the project dir  
> mkdir build  
> cd build  
> cmake -G "MinGW Makefiles" ..  
> make -j 

# Cpp11Example
## 右值引用(rvalue reference)
解释右值引用之前，首先要解释什么是左值、右值和引用  
左值(Lvalue)：有名字的对象。因为有名字，就可以在内存中找到位置，可以被访问。比如，变量x就是一个左值。  
右值(Rvalue)：没有名字的对象。即是一个临时对象。比如，数字42或表达式x+y都是右值。  
引用(Reference)：给一个已经有名字的对象(左值)创建一个别名(另一个左值)。比如&a = b  
如上可以很容易推导出右值引用的定义  
右值引用(Rvalue Reference): 给一个没有名字的对象(右值)赋予一个新的或已经存在的别名(左值)。比如&&a = 42，a是一个左值，&&a是一个右值引用。  

右值引用有什么用处  
值得一提的是，&&a = 42这种把右值直接绑定到右值引用的行为没有意义，仅仅是用于学习和理解什么是右值引用。  
在实际运用的时候，往往是将一个左值转换成右值后，在绑定到右值引用。  
因为如果把一个左值直接赋值给另一个左值，会出现拷贝。  
通过右值引用，可达到把一个左值赋值给另一个左值，又不引起拷贝。  

关于拷贝的一些实验  
观察程序在什么时候会出现拷贝。  
对于简单的数据类型，比如int，float，进行赋值的时候并不会出现拷贝，比如  
```c++
int a = 42;
```
这段代码把一个临时对象(右值)赋予左值，并没有出现拷贝。  
但是当=号右边也是左值的时候，会出现拷贝：  
```c++
int a = 42;
int b = a;
```
a和b都是左值(都有名字)，当处理到int b = a这条语句的时候，涉及到把名字为a内存里面的数据拷贝到名字为b的内存里。  
（这时候打印a和b的地址，观察结果: a和b的地址不同）  
如果不想发生拷贝，应该使用如下方式  
```c++
int a = 42;
int &&b = std::move(a);
```
std::move把a强行转化成右值，然后绑定到b上  
（这时候打印a和b的地址，观察结果：a和b的地址相同）  
另一个有趣的实验是不适用标准库函数std::move，而是使用强制转换，可以达到同样的效果  
```c++
int a = 42;
int &&b = (int &&)a;
```
（这时候打印a和b的地址，观察结果: a和b的地址相同）  
但是值得一提的是，虽然本例中std::move和(int &&)最后的结果相同，但是后者是更加低级的方法；如果是一个比较复杂的对象，后者容易出错，不太安全，还是推荐用std::move来进行安全的转换。  

以上例子说明了右值引用的好处。但int本身是简单的类型，拷贝本身开销也不大。  
然而，对于比较复杂的类的对象或容器，其拷贝的成本非常巨大，右值引用的好处就显现了。  

使用了int &&b = std::move(a)后，打印a的值会观察到什么？(其实还是42，因为int是简单类型，理论上资源移走了但还是原来的地址)  
如果是vector<int> int &&b = std::move(a)，输出a的值又会观察到什么呢？(其实还是没变化)  
在右值引用中，如果一个变量的资源被移走了，它仍然是有效的，但其状态会变成未定义。这时候它可以被安全销毁。  

## 在类中使用std::move
上面提到，std::move的作用是强制把左值转换成右值，从而实现赋值的时候避免拷贝资源(也就是"转移"资源)  

一个常见的应用场景是类中使用std::move实现高效率的类的资源转移(从而避免深拷贝)  
例如，原本类只有"拷贝构造函数"和"拷贝赋值运算符"进行深拷贝，对于两者来说，深拷贝的操作都无法避免  
现在，在类中添加"移动构造函数"(很像拷贝构造函数，但函数输入使用了&&而不是&，并且等号右边需要std::move)和"移动赋值运算符"(类似，函数输入也是&&,等号右边也是用std::move来转换)  

在使用的时候，如果使用MyClass obj1=obj2; 就会调用拷贝构造函数；如果使用obj1=std::move(obj2)就会使用移动构造函数，避免了拷贝过程  

同样，如果使用MyClass obj1; obj1=obj2; 就会调用拷贝赋值运算符；如果使用MyClass obj1; obj1=std::move(obj2)就会使用移动赋值运算符，避免了拷贝过程  

综上所述，在C++中，std::move是一个标准库函数，用于实现对象的移动语义。移动语义允许资源从一个对象转移到另一个对象，而不是进行昂贵的复制操作。这在处理动态内存分配、文件句柄等资源时特别有用，可以显著提高程序的性能。  
在C++11之前，复制对象通常会涉及深拷贝操作，这可能会非常昂贵，尤其是对于包含大量数据的对象。C++11引入了移动语义，通过移动构造函数和移动赋值运算符来优化这种情况。  

## 左值引用和右值引用的对比
左值引用：  
```c++
MyCustomDataType b = 10;
MyCustomDataType &a = b;
```
左值引用就是给b起了一个别名，a和b都是用同一个资源，并避免了拷贝  

右值引用：  
```c++
MyCustomDataType b = 10; 
MyCustomDataType &&a = std::move(b); 
```
右值引用在这里很有用处，它把b的资源转移到了a，也避免了拷贝  

区别是：  
- 左值引用中，不管修改a还是b，都可以修改同一个资源  
- 右值引用中，只有修改a才能修改资源，b的资源已经没有了  
- 在函数传参的过程中，常常使用左值引用，这样可以避免拷贝，并且函数内部可以改变传进来的资源  
- 如果有一个资源要从一个对象转移到另一个对象，那就需要右值引用了。因为左值引用只能“创建”别名，不能转移资源到一个已经存在的对象上  
- 另外，当类的成员函数返回临时对象的时候，编译器会尝试调用"移动构造函数"(如果有的话)；这样接收这个临时对象的变量就能在不进行拷贝的情况下接收该资源 

## Smart Pointer
Reference: https://github.com/gpuwangge/CppAddressExperiments  

## auto和decltype  
auto 关键字用于根据初始化表达式的值来推导变量的类型。  
```c++
auto x = 10;        // x 是 int
auto y = 3.14;      // y 是 double
auto z = x + y;     // z 是 double（因为 x + y 的结果是 double）
```

decltype 是用于获取一个表达式的类型，而不是值。  
```c++
int a = 5;
decltype(a) b = a;   // b 是 int
decltype((a)) c = a; // c 是 int&，因为 (a) 是左值表达式
```

decltype在模板中的用处  
```c++
template<typename T, typename U>
void multiply_and_print(T a, U b) {
    decltype(a * b) result = a * b;
    std::cout << result << std::endl;
}
```
这样你不需要手动声明 result 是 int、float、double、还是其他什么类型。  
上面也可以替换成auto result = a * b;  
区别是decltype可以精确获取表达式的“完整类型”（包括引用、const）  

## 转发函数（std::forward）
施工中


# Cpp98Example
## 内存分区模型
C和C++都一样  
Windows, Linux和macOS都一样  
- Code Segment：存编译后的二进制可执行代码，共享，只读  
- Data Segment(全局区)  
    Static Segment: 存全局变量(跨文件)和静态变量(局部)  
    Constant Segment：存常量数据(和静态变量的区别是必须定义时初始化，而且不可改变), 但是局部常量不在这里，在下面那个区  
- Stack Segment: 存局部变量，函数参数和函数调用的返回地址。由编译器分配。(不要返回局部变量的地址)  
- Heap Segment: 存动态内存  

结论1: 前两区是程序运行前建立的区，后面两区是程序运行后建立的区  
结论2: const修饰不决定数据放在哪里。如果是局部的就在stack区；全局的都在data区。  
结论3: static的都在data区。因为在整个程序生命周期都存在。  

## Friend
Friend让一个类或函数访问另一个类的私有成员  
1.全局函数做友元  
做一个全局函数，让它可以访问类的公有和私有属性。  
做法是，把全局函数的定义放在类的最前面，并加上friend关键字。  
2.类做友元  
做法是，把另一个类的名字拷贝到自己类的最前面，并加上friend关键字。  
3.成员函数做友元  
跟2相比，就是不把visit权限给整个类，而只是给类里面的某些成员函数。  

## 常函数
常函数：成员对象后面加上const  
常函数内不可修改成员变量（除非成员变量加了mutable)  

## 常对象
常对象：生命对象前加上const  
常对象只能调用常函数  

## this指針
在类的存放的时候，非静态成员变量和非静态成员函数是分开存放的。非静态成员变量每个对象存一份。但每个非静态成员函数只存一份，所有对象共享。  
问题是，对于非静态成员函数的代码，它不知道是哪个对象在调用它。this指针是为了解决这个问题，它指向调用这个非静态成员函数的类的对象。  
this指针不可修改  
每个非静态成员函数都有this指针，不需要单独设定。  
应用举例：链式编程  
```c++
Person& func(){  
    return *this;  
}
```

## 类和对象
空的对象大小是多少：占用1个字节。cpp编译器给空对象分配1字节空间，是为了区分位置。  
- 放一个int成员变量后，大小为4个字节。  
- 静态成员变量不影响类的对象的大小。  
- 放一个成员函数后，不影响类的对象的大小。(成员函数和成员变量分开存储)  
- 静态成员函数：也不影响类的对象的大小。  
结论：只有非静态成员变量位于类的对象上。  

## 重载
运算符重载可以在类里重载，也可以在全局重载。类里面重载没法指定顺序(比如<<)  

c++编译器给一个类创建的时候创建了四个默认函数  
构造  
析构  
拷贝构造(浅拷贝)  
赋值(浅拷贝)  

## 继承
子类继承父类之后，也会有一份父类的数据。  
比如父类有三个int(public, protected, provate), 子类有一个int，总大小就为16 bytes。  

cl和g++都有相应的命令可以查看类的对象详情  

如果父类和子类有同名成员，默认调用子类成员。如果加上作用域也可以调用父类成员。比如：s.Base::m_A  

允许一个子类继承多个类  

菱形继承：两个父类继承了一个类  
问题：子类继承了两份相同的数据  
解决办法：virtual inheritance  

## 纯虚函数和抽象类
因为父类virtual函数一般是没什么用的，可以改成纯虚函数(virtual = 0)  
类中只要有一个纯虚函数，就叫做抽象类，无法实例化。抽象类的子类必须重写抽象类的纯虚函数。  

## 多肽
overload其实是静态多肽  
polymorthism是运行阶段确定，是动态多肽  
要让地址晚绑定，使用virtual关键字  
动态多肽发动条件  
1.有继承关系   
2.重写父类virtual函数  
重写和重载的区别是，前者完全相同  
子类可以加上virtual，也可以不加virtual，没有影响  
3.使用的时候，使用父类的指针或引用来使用子类的对象  

多肽的底层原理  
如果一个类里面有一个函数，没有virtual修饰，算是一个空类，大小是1字节。如果用virtual修饰，大小变成4个字节。这4个字节是一个指针，指向virtual function table。  
VFT会存method address。当继承的时候，子类会继承父类的VFT。如果没有重写，那这个指针跟父类一样；如果发生了重写，指针会换成重写后的method adress。当用父类指针指向子类对象的时候，会直接访问VFT里的地址，也就是说假如发生了重写，必然调用的是子类的method。  

## 模版
template<typename T>  
template<class T>  
以上两个用法等同  

模版也分为函数模版和类模版两类。  
区别仅仅是类模版无法自动类型推导，也就是用<>显式指出类型。  

对于某个具体情况，可以使用具体化模版来解决特殊类型的通用化  

STL是基于模版来写的  

类模版的成员函数在调用的时候才确定  

类模版做参数对象  

类模版与继承：  
如果父类是模版，子类必须指定父类T的类型才行，不然会报错。  
要想更灵活一点，子类也要写成模版。并且子类的模版参数T继承自父类的模版参数T  

类模版成员函数可以类外实现：  
除了添加函数模版keyword，还要指定类模版参数列表  

类模版分文件编写：  
类模版成员函数创建时机是在调用阶段，会导致分文件编写时链接不到  
解决方式1:直接包含cpp源文件  
但实践中很少有人这么做  
解决方式2:将声明和实现写在同一个文件中，然后文件后缀改成hpp(改hpp并不是强制，只是约定成俗)  
大家约定俗成：当看见hpp文件之后，里面就有类模版  

类模版与友元：  
第一种方式：类内直接写  
第二种方式：类外需要提前让编译器知道全局函数的实现  
这种实现方式比较复杂。  

# CppBasicExample
## 常用位操作小技巧
### 判断奇偶
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用  
```c++
if((a & 1) == 0)  
```
代替if(a % 2 == 0)来判断a是不是偶数。  

### 交换两数  
```c++
a ^= b;
b ^= a;
a ^= b;
```

### 变换符号
因此变换符号只需要取反后加1即可  
```c++
~a + 1
```

### 求二进制数中1的个数  
```c++
for (c = 0; n; ++c)
	n = n&(n-1); // 清除最低位的1
```
举例：8（1000）= 7（0111）+ 1（0001），所以8 & 7 = （1000）&（0111）= 0（0000）  
再比如7（0111）= 6（0110）+ 1（0001），所以7 & 6 = （0111）&（0110）= 6（0110）  

查表法: 如果它是偶数，那么n的二进制中1的个数与n/2中1的个数是相同的  
如果n是奇数，那么n的二进制中1的个数是n/2中1的个数+1  
(http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)  

LSB: Least Significant Bits, 二进制的最右边那一位  
MSB: Most Significant Bits, 二进制的最左边那一位(在有符号数中就是符号位)  

## String Buffer
String STL use Copy-On-Write  
Reason of String Buffer: Create a buffer array  
string.append(x)  
rather then string = string + x  
写时才拷贝（Copy-On-Write）技术，就是编程界“懒惰行为”——拖延战术的产物。  
举个例子，比如我们有个程序要写文件，不断地根据网络传来的数据写, 如果每一次fwrite或是fprintf都要进行一个磁盘的I/O操作的话，都简直就是性能上巨大的损失，因此通常的做法是，每次写文件操作都写在特定大小的一块内存中（磁盘缓存），只有当我们关闭文件时，才写到磁盘上（这就是为什么如果文件不关闭，所写的东西会丢失的原因）。  
更有甚者是文件关闭时都不写磁盘，而一直等到关机或是内存不够时才写磁盘，Unix就是这样一个系统，如果非正常退出，那么数据就会丢失，文件就会损坏。  

## NP困难(NP - hard)
某个问题被称作NP困难，当且仅当存在一个NP完全问题可以在多项式时间图灵归约到这个问题。  
指问题NP困难的答案可用于解决NP完全问题.因此解决NP完全问题不会难于解决NP困难问题.  
栗子：旅行推销员问题（Travelling Salesman Problem)  
有n个城市，一个推销员要从其中某一个城市出发，唯一走遍所有的城市，再回到他出发的城市，求最短的路线。  
也即求一个最短的哈密顿回路。  
即使用dp也要指数时间  

## NP Problem完全问题
是NP（非决定性多项式时间）中最难的决定性问题.  
因此NP完备问题应该是最不可能被化简为P（多项式时间可决定）的决定性问题的集合。  
栗子：背包问题（Knapsack problem）  
给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。  
利用DP，背包问题存在一个伪多项式时间算法  

## 伪多项式时间
若一个数值算法的时间复杂度可以表示为输入数值N的多项式，则称其时间复杂度为伪多项式时间  

## try-finally语句
这就是try-finally语句最具有魔幻能力的地方，即不管在何种情况下，在离开当前的作用域时，  
finally块区域内的代码都将会被执行到。  

## final关键字
final关键字可以用于以下两种情况：  
1. 一个类或结构体不希望被继承。  
2. 一个虚函数不希望被override。  


