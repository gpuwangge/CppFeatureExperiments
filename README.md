# Build Instruction
Go to the project dir  
> mkdir build  
> cd build  
> cmake -G "MinGW Makefiles" ..  
> make  

# Cpp11Example
## 右值引用(rvalue reference)


## std::move
在C++中，move是一个标准库函数，用于实现对象的移动语义。移动语义允许资源从一个对象转移到另一个对象，而不是进行昂贵的复制操作。这在处理动态内存分配、文件句柄等资源时特别有用，可以显著提高程序的性能。  
在C++11之前，复制对象通常会涉及深拷贝操作，这可能会非常昂贵，尤其是对于包含大量数据的对象。C++11引入了移动语义，通过移动构造函数和移动赋值运算符来优化这种情况。  
(说人话就是原本类只有拷贝构造函数和赋值运算符进行深拷贝，Cpp11添加了移动构造函数和移动赋值运算符，提高了运行效率)  
std::move是一个标准库函数，它将其参数转换为右值引用（rvalue reference）。右值引用允许我们区分可以被移动的对象和不可以被移动的对象。  

不管是移动构造函数还是移动赋值运算符，核心代码如下：  
```c++
data = std::move(other.data)
```
  
# CppBasicExample
## 内存分区模型
C和C++都一样  
Windows, Linux和macOS都一样  
- Code Segment：存编译后的二进制可执行代码，共享，只读  
- Data Segment(全局区)  
    Static Segment: 存全局变量(跨文件)和静态变量(局部)  
    Constant Segment：存常量数据(和静态变量的区别是必须定义时初始化，而且不可改变), 但是局部常量不在这里，在下面那个区  
- Stack Segment: 存局部变量，函数参数和函数调用的返回地址。由编译器分配。(不要返回局部变量的地址)  
- Heap Segment: 存动态内存  

结论1: 前两区是程序运行前建立的区，后面两区是程序运行后建立的区  
结论2: const修饰不决定数据放在哪里。如果是局部的就在stack区；全局的都在data区。  
结论3: static的都在data区。因为在整个程序生命周期都存在。  

## Friend
Friend让一个类或函数访问另一个类的私有成员  
1.全局函数做友元  
做一个全局函数，让它可以访问类的公有和私有属性。  
做法是，把全局函数的定义放在类的最前面，并加上friend关键字。  
2.类做友元  
做法是，把另一个类的名字拷贝到自己类的最前面，并加上friend关键字。  
3.成员函数做友元  
跟2相比，就是不把visit权限给整个类，而只是给类里面的某些成员函数。  

## 常函数
常函数：成员对象后面加上const  
常函数内不可修改成员变量（除非成员变量加了mutable)  

## 常对象
常对象：生命对象前加上const  
常对象只能调用常函数  

## this指針
在类的存放的时候，非静态成员变量和非静态成员函数是分开存放的。非静态成员变量每个对象存一份。但每个非静态成员函数只存一份，所有对象共享。  
问题是，对于非静态成员函数的代码，它不知道是哪个对象在调用它。this指针是为了解决这个问题，它指向调用这个非静态成员函数的类的对象。  
this指针不可修改  
每个非静态成员函数都有this指针，不需要单独设定。  
应用举例：链式编程  
```c++
Person& func(){  
    return *this;  
}
```

## 类和对象
空的对象大小是多少：占用1个字节。cpp编译器给空对象分配1字节空间，是为了区分位置。  
- 放一个int成员变量后，大小为4个字节。  
- 静态成员变量不影响类的对象的大小。  
- 放一个成员函数后，不影响类的对象的大小。(成员函数和成员变量分开存储)  
- 静态成员函数：也不影响类的对象的大小。  
结论：只有非静态成员变量位于类的对象上。  

## 重载
运算符重载可以在类里重载，也可以在全局重载。类里面重载没法指定顺序(比如<<)  

c++编译器给一个类创建的时候创建了四个默认函数  
构造  
析构  
拷贝构造(浅拷贝)  
赋值(浅拷贝)  

## 继承
子类继承父类之后，也会有一份父类的数据。  
比如父类有三个int(public, protected, provate), 子类有一个int，总大小就为16 bytes。  

cl和g++都有相应的命令可以查看类的对象详情  

如果父类和子类有同名成员，默认调用子类成员。如果加上作用域也可以调用父类成员。比如：s.Base::m_A  

允许一个子类继承多个类  

菱形继承：两个父类继承了一个类  
问题：子类继承了两份相同的数据  
解决办法：virtual inheritance  

## 纯虚函数和抽象类
因为父类virtual函数一般是没什么用的，可以改成纯虚函数(virtual = 0)  
类中只要有一个纯虚函数，就叫做抽象类，无法实例化。抽象类的子类必须重写抽象类的纯虚函数。  

## 多肽
overload其实是静态多肽  
polymorthism是运行阶段确定，是动态多肽  
要让地址晚绑定，使用virtual关键字  
动态多肽发动条件  
1.有继承关系   
2.重写父类virtual函数  
重写和重载的区别是，前者完全相同  
子类可以加上virtual，也可以不加virtual，没有影响  
3.使用的时候，使用父类的指针或引用来使用子类的对象  

多肽的底层原理  
如果一个类里面有一个函数，没有virtual修饰，算是一个空类，大小是1字节。如果用virtual修饰，大小变成4个字节。这4个字节是一个指针，指向virtual function table。  
VFT会存method address。当继承的时候，子类会继承父类的VFT。如果没有重写，那这个指针跟父类一样；如果发生了重写，指针会换成重写后的method adress。当用父类指针指向子类对象的时候，会直接访问VFT里的地址，也就是说假如发生了重写，必然调用的是子类的method。  

## 模版
template<typename T>  
template<class T>  
以上两个用法等同  

模版也分为函数模版和类模版两类。  
区别仅仅是类模版无法自动类型推导，也就是用<>显式指出类型。  

对于某个具体情况，可以使用具体化模版来解决特殊类型的通用化  

STL是基于模版来写的  

类模版的成员函数在调用的时候才确定  

类模版做参数对象  

类模版与继承：  
如果父类是模版，子类必须指定父类T的类型才行，不然会报错。  
要想更灵活一点，子类也要写成模版。并且子类的模版参数T继承自父类的模版参数T  

类模版成员函数可以类外实现：  
除了添加函数模版keyword，还要指定类模版参数列表  

类模版分文件编写：  
类模版成员函数创建时机是在调用阶段，会导致分文件编写时链接不到  
解决方式1:直接包含cpp源文件  
但实践中很少有人这么做  
解决方式2:将声明和实现写在同一个文件中，然后文件后缀改成hpp(改hpp并不是强制，只是约定成俗)  
大家约定俗成：当看见hpp文件之后，里面就有类模版  

类模版与友元：  
第一种方式：类内直接写  
第二种方式：类外需要提前让编译器知道全局函数的实现  
这种实现方式比较复杂。  


